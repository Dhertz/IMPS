\documentclass[a5=4paper,12pt]{article}

\begin{document}
\setlength{\topmargin}{-1cm} %Was a bit bottom heavy in my opinon
\title{IMPS Report}
\author{Owen Davies, Daniel Hertz, Charlie Hothersall-Thomas}
\date{ \today}

\maketitle
\section*{The IMPS Debugger} %asterix stops enumerating sections
The extension we decided to produce as an IMPS debugger, with as many useful functions as we could add in the timeframe given. The debugger has the capability to set breakpoints, print or edit registers and memory, and step line by line through a developers code. This is obviously useful for the assembly developer, as if the program has to act in a predictable manor under all circumstances, and out extension allows us to show the developer where they are having unexpected behaviour. \\ %newline
\textbf{/*flow or state diagram goes here*/ }
\subsection*{Design}      
The design of the debugger is relatively simple as shown above - using functions shared with assemble and emulate, the debugger compiles the source to memory (instead of a file like assembler). The user can then input commands before running the program, such as breakpoints, or set a specific state of registers and memory. The program is then run to the first breakpoint, where a different interface is presented. The user can now print the state they are currently at, step through the next few lines of code, or set the registers again. This design is implemented using two separate while loops with switches for interfaces, and a loop that runs the program up to the breakpoint, then after it. One of the problems we discovered with this method was the data and skip commands, as we weren't sure how to act if the user set one as a breakpoint, and how to skip the correct number of bytes in memory. The first was a functionality question, and we decided to stop the program if the user did something this silly. The second required passing the state to the assembler, as it then has the location to zero out the number of bytes required.
\subsection*{Testing}
The debugger was tested rigorously and thoroughly by Owen. It works.
\section*{Programming in a Group}
\begin{center}\textit{Producing a software suite for an imaginary language has never been so for-filling.} \end{center}
Programming in the group has been a good experience for all of us, as we have learnt equal parts group coding skills and C. We mainly divided up by doing what we were interested in, but always checking and making edits to everyone else's work, so the whole group knew the progress that had been made. One of the major learning points for one of the group members was the use of git, which he was very sceptical about in the beginning, as he didn't really understand the use case. The other two members have now taught the importance of version control, but admit that we were not doing it quite right. We had a shared repository, on which we all had our own branches and pushed and pulled from, and the master was holy, and only to be touched if we are sure. This is an antiquated model of Subversion. We learnt were git really excels -  its distributed model. If we each had our own repository, each with our master, then we could branch of and do some experimental work on our own and merge it into out master branch. If then the rest of the group members wanted by change, and we agreed it was good, then they would pull from the individuals repo. This makes git much more powerful and easier to use, with nicer merges. Our methods communication went through a number of iterations, first it was mostly in-person, but either someone would be left out of the loop, or if we were programming, have not much to do. We then decided to split up tasks a bit more, and two of us pair-programming on a larger project, while in parallel the other was working on something related. This worked for some time, but as we came under more time pressure, the natural thing came to us. Facebook group chat, each working in parallel on something different, and then everyone checking each others work. This way, everyone knew what everyone else was doing and we could quickly ask any questions about the design or methodology the others were happy to use. Another powerful tool we used was gitHub to track our commits. This means whenever we happen to meet, the code is available to us online, and we could discuss changes or possible design considerations, as well as seeing easy 'diffs' of commits.\\
All in all we have really enjoyed working together and it has made us better people for it. Now I can't wait for summer!
\end{document}